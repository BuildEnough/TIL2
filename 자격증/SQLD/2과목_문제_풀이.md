1. DCL
- GRANT
- ROLLBACK

2. DDL
- CREATE
- ALTER
- DROP
- REMANE

3. TCL
- 논리적인 작업의 단위를 묶어 DML에 의해 조작된 결과를 작업 단위별로 제어하는 명령어인 COMMIT, ROLLBACK, SAVEPOINT 등이 여기에 해당하며, 일부에서는 DCL로 분류하기도 한다

4. 절차적 데이터 조작어
- 어떻게 데이터를 접근해야 하는지 명시한다
- **비절차적 데이터 조작어**는 사용자가 무슨 데이터를 원하는지만 명세

5. SQL
- DML: SELECT, INSERT, UPDATE, DELETE
- DDL: CREATE, ALTER, DROP, RENAME
- DCL: GRANT, REVOKE
- TCL: COMMIT, ROLLBACK

6. SQL
- 문법

7. SQL
- 여러 개의 칼럼을 동시에 수정하는 구문은 지원하지 않으므로 오류가 발생함
- NOT NULL 조건 상세히 보기

8. NULL
- NULL은 공백문자(Empty String) 혹은 숫자 0과 동일하지 않다

9. SQL
- CASECADE와 SET NULL 조건

10. UNIQUE
- UNIQUE는 테이블 내에서 중복되는 값이 없지만, NULL 입력이 가능함

11. 테이블 명
- 테이블 명은 반드시 문자로 시작해야함

12. SQL
- 문법

13. SQL
- 문법

14. 외래키
- 테이블 생성 시 설정 가능
- 외래키 값은  NULL 값을 가질 수 있다
- 한 테이블에 여러 개 존재 가능
- 외래키 값은 무결성 제약을 받을 수 있다

15. 제약조건
- 고유키(Unique)로 지정된 모든 컬럼은 NULL 값을 가질 수 있다

16. SQL
- 문법

17. 참조무결성 규정
- Casecade: Master 삭제 시, Child 같이 삭제

18. RENAME
- RENAME 기존 테이블 명 TO 변경될 테이블 명

19. DEPENDENT
- Master 테이블에 PK가 존재할 때만 Child 입력 허용

20. SQL 문
- 문법

21. SQL 문
- NOT NULL 제약조건 확인

22. SQL 문
- 문법

23. 테이블 데이터 삭제
- TRUNCATE와 DROP는 로그를 남기지 않음
- DELETE를 사용하는 것이 개발팀 입장에서 좋음

24. DISTINCT
- 중복된 데이터가 있는 경우 1건으로 처리해서 출력함

25. TRUNCATE
- 테이블 자체가 삭제되는 것이 아니고, 해당 테이블에 들어있던 모든 행들이 제거되고 저장 공간을 재사용 가능하도록 해제한다
- 테이블 구조를 완전히 삭제하기 위해서는 DROP TABLE을 실행하면 된다

26. DROP, TURNCATE, DELETE
- 차이 알기

27. 트랜잭션 특성(ACID)
- 원자성: 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다
- 일관성: 트랜잭션이 실행되기 전의 테이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다
- 고립성: 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다
- 지속성: 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다

28. 데이터베이스 트랜잭션 격리성이 낮은 경우
- Dirty Read: 다른 트랜잭션에 의해 수정되었지만, 아직 커밋되지 않은 데이터를 읽는 것
- Non_Repeatable Read: 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리의 결과가 다르게 나타나는 현상
- Phantom Read: 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상

29. SQL 문제

30. 트랜잭션
- 트랜잭션: 데이터베이스의 논리적 연산단위로 밀접히 관련되어 분리될 수 없는 한개 이상의 데이터베이스 조작을 가리킨다
- COMMIT: 데이터에 대한 변경사항을 데이터베이스에 영구적으로 반영
- ROLLBACK: 데이터에 대한 변경사항을 모두 폐기하고 변경 전의 상태로 되돌림

31. BEGIN TRANSACTION
- ROLLBACK 구문은 COMMIT되지 안흔 모든 Transaction을 모두 ROLLBACK한다

32. SQL 문제

33. WHERE절
- 데이터베이스에서 데이터를 조회할 때 원하는 데이터만을 검색하기 위해 SELECT, FROM 절과 함께 SELECT절을 이용하여 조회되는 데이터의 조건을 설정하여 데이터를 제한할 수 있다

34. 논리 연산자 우선 순위
- NOT > AND > OR

35. NULL
- NULL 값이 포함된 4칙 연산의 결과는 NULL

36. NULL 조건
- NULL이 아닌 경우를 찾아내는 문장: IS NOT NULL

37. SQL문

38. BETWEEN a AND b
- a와 b의 값 사이에 있으면 된다

39. SQL문
- 다시 풀어보기

40. 내장 함수
- 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다
- 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET절에 사용가능하다
- 1:M 조인이라 하다라도 M쪽에서 출력된 행이 하나씩 단일행 함수의 입력값으로 사용되므로 사용할 수 있다
- 다중행 함수도 단일행 함수와 동일하게 단일 값만을 반환한다
- 함수는 벤더에서 제공하는 함수인 내장함수와 사용자가 정의할 수 있는 함수로 나눌 수 있다
- 내장함수는 다시 단일행 함수와 다중행 함수로 나눌 수 있으며, 다중행 ㅎ마수는 집계 함수, 그룹 함수, 윈도우 함수로 구분된다

41. SQL
- LENGTH: 문자열의 길이를 반환하는 함수
- CHR: 주어진 ASC2 코드에 대한 문자를 반환하는 함수
- REPLACE: 문자열을 치환하는 함수

42. 오라클 환경에서의 날짜 계산
- 특정 날짜에 1을 더하면 하루를 더한 결과와 같음

43. SQL문
- 다시 풀어보기

44. SQL 문
- 다시 풀어보기

45. SQL
- 결과값이 NULL이 아닌 다른 값을 얻고자 할 때 NVL/ISNULL 함수를 사용한다
- NULL 값의 대상이 숫자 유형 데이터인 경우는 주로 0
- 문자 유형 데이터인 경우는 블랭크보다는 x같이 해당 시스템에서 의미 없는 문자로 바꾸는 경우가 많다

46. 단일행 NULL 관련 함수
- NVL(표현식1, 표현식2) ISNULL(표현식1, 표현식2): 표현식1의 결과값이 NULL이면 표현식2의 값을 출력(표현식1과 표현식2의 결과 데이터 값이 같아야 함)
- NULLIF(표현식1, 표현식2): 표현식1이 표현식2와 같으면 NULL을, 같지 않으면 표현식1을 리턴
- COALESCE(표현식1, 표현식2): 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식을 나타낸다, 모든 표현식이 NULL이라면 NULL을 리턴함

47. NULL 포함 연산 결과
- NULL이 포하된 연산의 결과는 NULL
- 분모가 0이 들어가는 경우 연산 자체가 에러를 발생시켜 원하는 결과를 얻을 수 없다

48. COALESCE
- COALESCE: 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식을 나타냄

49. 단일행 NULL 관련 함수
- NVL(표현식1, 표현식2) ISNULL(표현식1, 표현식2): 표현식1의 결과값이 NULL이면 표현식2의 값을 출력(표현식1과 표현식2의 결과 데이터 값이 같아야 함)
- NULLIF(표현식1, 표현식2): 표현식1이 표현식2와 같으면 NULL을, 같지 않으면 표현식1을 리턴
- COALESCE(표현식1, 표현식2): 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식을 나타낸다, 모든 표현식이 NULL이라면 NULL을 리턴함

50. AVG 함수
- 표현식의 NULL 값을 제외한 평균 출력

51.  SQL 문제
- COUNT: NULL값 제외 후 카운트
- GROUP BY

52. SQL문
- 다시 풀어보기

53. SQL문
- 다시 풀어보기

54번 ~ 64번: SQl 문제

65. 순수관계 연산자
- SELECT, POJECT, JOIN, DIVIDE

66. SQL문
- 다시 풀어보기

67. INNER JOIN
- JOIN 조건에서 동일한 값이 있는 행만 반환함

68. SQL
- INEER JOIN, COUNT함수

69. SQL

70. SQL

71. CROSS JOIN
- 테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합
- 결과는 양쪽 집합의 M*N 건의 데이터 조합이 발생함

72. LEFT OUTER JOIN
- 조인 수행시 먼저 표기된 좌측 테이블에 해당하는 데이터를 먼저 읽은 후, 나중 표기된 우측 테이블에서 JOIN 대상 데이터를 읽어온다

73. FULL OUTER JOIN
- 조인 수행시, 좌측, 우측 테이블의 모든 데이터를 읽어 JOIN하여 결과를 생성한다. 즉, TABLE A와 B가 있을 때 RIGHT OUTER JOIN과 LEFT OUTER JOIN의 결과를 합집합으로 처리한 결과와 동일함

74. LEFT JOIN, FULL JOIN, RIGHT JOIN

75. LEFT JOIM

76. OUTER JOIN
- OUTER JOINDPTJ ON절은 조인할 대상을 결정한다
- 기준 테이블은 항상 모두 표시됨 

88. Oracle 계층형 질의
- START WITH: 계층 구조 전개의 시작 위치를 지정하는 구문
- ORDER SIBINGS BY: 형제 노드 사이에서 정렬 수행

90. 계층형 질의문
- 테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해서 계층형 질의를 사용
- 동일 테이블에 계층적으로 상위와 하위 데이터가 포함된 데이터
- SQL Server에서의 계층형 질의문은 CTE를 재귀 호출함으로써 계층 구조를 전개
- SQL Server에서의 계층형 질의문은 앵커 멤버를 실행하여 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행
- 오라클의 계층형 질의문에서 WHERE 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는데 활용됨
- 오라클 계층형 질의에서 루트 노드의 LEVEL 값은 1

92. 셀프 조인(Self Join)
- 하나의 테이블에서 두 개의 컬럼이 연관 관계를 가지고 있는 경우에 사용
- 동일 테이블 사이의 조인을 말하며, FROM 절에 동일 테이블이 두 번 이상 나타난다
- 동일 테이블 사이의 조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에 식별을 위해 반드시 테이블 별칭을 사용해야 한다

95. 서브쿼리
- 서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용할 수 있다
- 서브 쿼리는 SELECT절, FROM절, HAVING절, ORDER BY절 등에서 사용이 가능하다
- 서브쿼리의 결과가 복수 행 결과를 반환하는 경우에는 IN, ALL, ANY 등의 복수 행 비교 연산자와 사용하여야 한다
- 연관 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다
- 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인 쿼리의 조건과 비교되는데, SQL Server에서는 현재 지원하지 않는 기능이다

97. 서브쿼리 사용시 주의 사항
- 서브쿼리를 괄호로 감싸서 사용
- 서브쿼리는 단일행 또는 복수 행 비교 연산자와 함께 사용 가능
- 단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이어야하고 복수 행 비교 연산자는 서브쿼리의 결과건수와 상관없다
- 서브쿼리에서는 ORDER BY를 사용하지 못한다
- ORDER BY절은 SELECT절에서 오직 한 개만 올 수 있기 때문에 ORDER BY절은 메인쿼리의 마지막 문장에 위치해야 한다

99. 서브쿼리
- 단일 행 서브쿼리 비교연산자로는 =, <, <=, =, >, >=, <>가 되어야 한다.
- IN, ALL 등의 비교 연산자는 다중 행 서브쿼리의 비교연산자이다
- 단일 행 서브쿼리의 비교연산자는 다중 행 서브쿼리의 비교연산자로 사용할 수 없지만, 다중 행 서브쿼리 비교 연산자는 단일 행 서브쿼리의 비교 연산자로도 사용할 수 있다
- 비 연관 서브쿼리가 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용된다
- 메인 쿼리의 결과가 서브쿼리로 제공될 수도 있고, 서브쿼리의 결과가 메인쿼리로 제공될 수도 있으므로 실행 순서는 상황에 따라 달라진다

